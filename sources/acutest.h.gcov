        -:    0:Source:../includes/acutest.h
        -:    0:Graph:.\UT_CanNM.gcno
        -:    0:Data:.\UT_CanNM.gcda
        -:    0:Runs:5
        -:    0:Programs:1
        -:    1:/*
        -:    2: * Acutest -- Another C/C++ Unit Test facility
        -:    3: * <https://github.com/mity/acutest>
        -:    4: *
        -:    5: * Copyright 2013-2020 Martin Mitas
        -:    6: * Copyright 2019 Garrett D'Amore
        -:    7: *
        -:    8: * Permission is hereby granted, free of charge, to any person obtaining a
        -:    9: * copy of this software and associated documentation files (the "Software"),
        -:   10: * to deal in the Software without restriction, including without limitation
        -:   11: * the rights to use, copy, modify, merge, publish, distribute, sublicense,
        -:   12: * and/or sell copies of the Software, and to permit persons to whom the
        -:   13: * Software is furnished to do so, subject to the following conditions:
        -:   14: *
        -:   15: * The above copyright notice and this permission notice shall be included in
        -:   16: * all copies or substantial portions of the Software.
        -:   17: *
        -:   18: * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        -:   19: * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        -:   20: * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
        -:   21: * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        -:   22: * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
        -:   23: * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
        -:   24: * IN THE SOFTWARE.
        -:   25: */
        -:   26:
        -:   27:#ifndef ACUTEST_H
        -:   28:#define ACUTEST_H
        -:   29:
        -:   30:
        -:   31:/************************
        -:   32: *** Public interface ***
        -:   33: ************************/
        -:   34:
        -:   35:/* By default, "acutest.h" provides the main program entry point (function
        -:   36: * main()). However, if the test suite is composed of multiple source files
        -:   37: * which include "acutest.h", then this causes a problem of multiple main()
        -:   38: * definitions. To avoid this problem, #define macro TEST_NO_MAIN in all
        -:   39: * compilation units but one.
        -:   40: */
        -:   41:
        -:   42:/* Macro to specify list of unit tests in the suite.
        -:   43: * The unit test implementation MUST provide list of unit tests it implements
        -:   44: * with this macro:
        -:   45: *
        -:   46: *   TEST_LIST = {
        -:   47: *       { "test1_name", test1_func_ptr },
        -:   48: *       { "test2_name", test2_func_ptr },
        -:   49: *       ...
        -:   50: *       { NULL, NULL }     // zeroed record marking the end of the list
        -:   51: *   };
        -:   52: *
        -:   53: * The list specifies names of each test (must be unique) and pointer to
        -:   54: * a function implementing it. The function does not take any arguments
        -:   55: * and has no return values, i.e. every test function has to be compatible
        -:   56: * with this prototype:
        -:   57: *
        -:   58: *   void test_func(void);
        -:   59: *
        -:   60: * Note the list has to be ended with a zeroed record.
        -:   61: */
        -:   62:#define TEST_LIST               const struct test_ test_list_[]
        -:   63:
        -:   64:
        -:   65:/* Macros for testing whether an unit test succeeds or fails. These macros
        -:   66: * can be used arbitrarily in functions implementing the unit tests.
        -:   67: *
        -:   68: * If any condition fails throughout execution of a test, the test fails.
        -:   69: *
        -:   70: * TEST_CHECK takes only one argument (the condition), TEST_CHECK_ allows
        -:   71: * also to specify an error message to print out if the condition fails.
        -:   72: * (It expects printf-like format string and its parameters). The macros
        -:   73: * return non-zero (condition passes) or 0 (condition fails).
        -:   74: *
        -:   75: * That can be useful when more conditions should be checked only if some
        -:   76: * preceding condition passes, as illustrated in this code snippet:
        -:   77: *
        -:   78: *   SomeStruct* ptr = allocate_some_struct();
        -:   79: *   if(TEST_CHECK(ptr != NULL)) {
        -:   80: *       TEST_CHECK(ptr->member1 < 100);
        -:   81: *       TEST_CHECK(ptr->member2 > 200);
        -:   82: *   }
        -:   83: */
        -:   84:#define TEST_CHECK_(cond,...)   test_check_((cond), __FILE__, __LINE__, __VA_ARGS__)
        -:   85:#define TEST_CHECK(cond)        test_check_((cond), __FILE__, __LINE__, "%s", #cond)
        -:   86:
        -:   87:
        -:   88:/* These macros are the same as TEST_CHECK_ and TEST_CHECK except that if the
        -:   89: * condition fails, the currently executed unit test is immediately aborted.
        -:   90: *
        -:   91: * That is done either by calling abort() if the unit test is executed as a
        -:   92: * child process; or via longjmp() if the unit test is executed within the
        -:   93: * main Acutest process.
        -:   94: *
        -:   95: * As a side effect of such abortion, your unit tests may cause memory leaks,
        -:   96: * unflushed file descriptors, and other phenomena caused by the abortion.
        -:   97: *
        -:   98: * Therefore you should not use these as a general replacement for TEST_CHECK.
        -:   99: * Use it with some caution, especially if your test causes some other side
        -:  100: * effects to the outside world (e.g. communicating with some server, inserting
        -:  101: * into a database etc.).
        -:  102: */
        -:  103:#define TEST_ASSERT_(cond,...)                                                 \
        -:  104:    do {                                                                       \
        -:  105:        if(!test_check_((cond), __FILE__, __LINE__, __VA_ARGS__))              \
        -:  106:            test_abort_();                                                     \
        -:  107:    } while(0)
        -:  108:#define TEST_ASSERT(cond)                                                      \
        -:  109:    do {                                                                       \
        -:  110:        if(!test_check_((cond), __FILE__, __LINE__, "%s", #cond))              \
        -:  111:            test_abort_();                                                     \
        -:  112:    } while(0)
        -:  113:
        -:  114:
        -:  115:#ifdef __cplusplus
        -:  116:/* Macros to verify that the code (the 1st argument) throws exception of given
        -:  117: * type (the 2nd argument). (Note these macros are only available in C++.)
        -:  118: *
        -:  119: * TEST_EXCEPTION_ is like TEST_EXCEPTION but accepts custom printf-like
        -:  120: * message.
        -:  121: *
        -:  122: * For example:
        -:  123: *
        -:  124: *   TEST_EXCEPTION(function_that_throw(), ExpectedExceptionType);
        -:  125: *
        -:  126: * If the function_that_throw() throws ExpectedExceptionType, the check passes.
        -:  127: * If the function throws anything incompatible with ExpectedExceptionType
        -:  128: * (or if it does not thrown an exception at all), the check fails.
        -:  129: */
        -:  130:#define TEST_EXCEPTION(code, exctype)                                          \
        -:  131:    do {                                                                       \
        -:  132:        bool exc_ok_ = false;                                                  \
        -:  133:        const char *msg_ = NULL;                                               \
        -:  134:        try {                                                                  \
        -:  135:            code;                                                              \
        -:  136:            msg_ = "No exception thrown.";                                     \
        -:  137:        } catch(exctype const&) {                                              \
        -:  138:            exc_ok_= true;                                                     \
        -:  139:        } catch(...) {                                                         \
        -:  140:            msg_ = "Unexpected exception thrown.";                             \
        -:  141:        }                                                                      \
        -:  142:        test_check_(exc_ok_, __FILE__, __LINE__, #code " throws " #exctype);   \
        -:  143:        if(msg_ != NULL)                                                       \
        -:  144:            test_message_("%s", msg_);                                         \
        -:  145:    } while(0)
        -:  146:#define TEST_EXCEPTION_(code, exctype, ...)                                    \
        -:  147:    do {                                                                       \
        -:  148:        bool exc_ok_ = false;                                                  \
        -:  149:        const char *msg_ = NULL;                                               \
        -:  150:        try {                                                                  \
        -:  151:            code;                                                              \
        -:  152:            msg_ = "No exception thrown.";                                     \
        -:  153:        } catch(exctype const&) {                                              \
        -:  154:            exc_ok_= true;                                                     \
        -:  155:        } catch(...) {                                                         \
        -:  156:            msg_ = "Unexpected exception thrown.";                             \
        -:  157:        }                                                                      \
        -:  158:        test_check_(exc_ok_, __FILE__, __LINE__, __VA_ARGS__);                 \
        -:  159:        if(msg_ != NULL)                                                       \
        -:  160:            test_message_("%s", msg_);                                         \
        -:  161:    } while(0)
        -:  162:#endif  /* #ifdef __cplusplus */
        -:  163:
        -:  164:
        -:  165:/* Sometimes it is useful to split execution of more complex unit tests to some
        -:  166: * smaller parts and associate those parts with some names.
        -:  167: *
        -:  168: * This is especially handy if the given unit test is implemented as a loop
        -:  169: * over some vector of multiple testing inputs. Using these macros allow to use
        -:  170: * sort of subtitle for each iteration of the loop (e.g. outputting the input
        -:  171: * itself or a name associated to it), so that if any TEST_CHECK condition
        -:  172: * fails in the loop, it can be easily seen which iteration triggers the
        -:  173: * failure, without the need to manually output the iteration-specific data in
        -:  174: * every single TEST_CHECK inside the loop body.
        -:  175: *
        -:  176: * TEST_CASE allows to specify only single string as the name of the case,
        -:  177: * TEST_CASE_ provides all the power of printf-like string formatting.
        -:  178: *
        -:  179: * Note that the test cases cannot be nested. Starting a new test case ends
        -:  180: * implicitly the previous one. To end the test case explicitly (e.g. to end
        -:  181: * the last test case after exiting the loop), you may use TEST_CASE(NULL).
        -:  182: */
        -:  183:#define TEST_CASE_(...)         test_case_(__VA_ARGS__)
        -:  184:#define TEST_CASE(name)         test_case_("%s", name)
        -:  185:
        -:  186:
        -:  187:/* Maximal output per TEST_CASE call. Longer messages are cut.
        -:  188: * You may define another limit prior including "acutest.h"
        -:  189: */
        -:  190:#ifndef TEST_CASE_MAXSIZE
        -:  191:    #define TEST_CASE_MAXSIZE    64
        -:  192:#endif
        -:  193:
        -:  194:
        -:  195:/* printf-like macro for outputting an extra information about a failure.
        -:  196: *
        -:  197: * Intended use is to output some computed output versus the expected value,
        -:  198: * e.g. like this:
        -:  199: *
        -:  200: *   if(!TEST_CHECK(produced == expected)) {
        -:  201: *       TEST_MSG("Expected: %d", expected);
        -:  202: *       TEST_MSG("Produced: %d", produced);
        -:  203: *   }
        -:  204: *
        -:  205: * Note the message is only written down if the most recent use of any checking
        -:  206: * macro (like e.g. TEST_CHECK or TEST_EXCEPTION) in the current test failed.
        -:  207: * This means the above is equivalent to just this:
        -:  208: *
        -:  209: *   TEST_CHECK(produced == expected);
        -:  210: *   TEST_MSG("Expected: %d", expected);
        -:  211: *   TEST_MSG("Produced: %d", produced);
        -:  212: *
        -:  213: * The macro can deal with multi-line output fairly well. It also automatically
        -:  214: * adds a final new-line if there is none present.
        -:  215: */
        -:  216:#define TEST_MSG(...)           test_message_(__VA_ARGS__)
        -:  217:
        -:  218:
        -:  219:/* Maximal output per TEST_MSG call. Longer messages are cut.
        -:  220: * You may define another limit prior including "acutest.h"
        -:  221: */
        -:  222:#ifndef TEST_MSG_MAXSIZE
        -:  223:    #define TEST_MSG_MAXSIZE    1024
        -:  224:#endif
        -:  225:
        -:  226:
        -:  227:/* Macro for dumping a block of memory.
        -:  228: *
        -:  229: * Its intended use is very similar to what TEST_MSG is for, but instead of
        -:  230: * generating any printf-like message, this is for dumping raw block of a
        -:  231: * memory in a hexadecimal form:
        -:  232: *
        -:  233: *   TEST_CHECK(size_produced == size_expected &&
        -:  234: *              memcmp(addr_produced, addr_expected, size_produced) == 0);
        -:  235: *   TEST_DUMP("Expected:", addr_expected, size_expected);
        -:  236: *   TEST_DUMP("Produced:", addr_produced, size_produced);
        -:  237: */
        -:  238:#define TEST_DUMP(title, addr, size)    test_dump_(title, addr, size)
        -:  239:
        -:  240:/* Maximal output per TEST_DUMP call (in bytes to dump). Longer blocks are cut.
        -:  241: * You may define another limit prior including "acutest.h"
        -:  242: */
        -:  243:#ifndef TEST_DUMP_MAXSIZE
        -:  244:    #define TEST_DUMP_MAXSIZE   1024
        -:  245:#endif
        -:  246:
        -:  247:
        -:  248:/* Common test initialiation/clean-up
        -:  249: *
        -:  250: * In some test suites, it may be needed to perform some sort of the same
        -:  251: * initialization and/or clean-up in all the tests.
        -:  252: *
        -:  253: * Such test suites may use macros TEST_INIT and/or TEST_FINI prior including
        -:  254: * this header. The expansion of the macro is then used as a body of helper
        -:  255: * function called just before executing every single (TEST_INIT) or just after
        -:  256: * it ends (TEST_FINI).
        -:  257: *
        -:  258: * Examples of various ways how to use the macro TEST_INIT:
        -:  259: *
        -:  260: *   #define TEST_INIT      my_init_func();
        -:  261: *   #define TEST_INIT      my_init_func()      // Works even without the semicolon
        -:  262: *   #define TEST_INIT      setlocale(LC_ALL, NULL);
        -:  263: *   #define TEST_INIT      { setlocale(LC_ALL, NULL); my_init_func(); }
        -:  264: *
        -:  265: * TEST_FINI is to be used in the same way.
        -:  266: */
        -:  267:
        -:  268:
        -:  269:/**********************
        -:  270: *** Implementation ***
        -:  271: **********************/
        -:  272:
        -:  273:/* The unit test files should not rely on anything below. */
        -:  274:
        -:  275:#include <ctype.h>
        -:  276:#include <stdarg.h>
        -:  277:#include <stdio.h>
        -:  278:#include <stdlib.h>
        -:  279:#include <string.h>
        -:  280:#include <setjmp.h>
        -:  281:
        -:  282:#if defined(unix) || defined(__unix__) || defined(__unix) || defined(__APPLE__)
        -:  283:    #define ACUTEST_UNIX_       1
        -:  284:    #include <errno.h>
        -:  285:    #include <libgen.h>
        -:  286:    #include <unistd.h>
        -:  287:    #include <sys/types.h>
        -:  288:    #include <sys/wait.h>
        -:  289:    #include <signal.h>
        -:  290:    #include <time.h>
        -:  291:
        -:  292:    #if defined CLOCK_PROCESS_CPUTIME_ID  &&  defined CLOCK_MONOTONIC
        -:  293:        #define ACUTEST_HAS_POSIX_TIMER_    1
        -:  294:    #endif
        -:  295:#endif
        -:  296:
        -:  297:#if defined(_gnu_linux_)
        -:  298:    #define ACUTEST_LINUX_      1
        -:  299:    #include <fcntl.h>
        -:  300:    #include <sys/stat.h>
        -:  301:#endif
        -:  302:
        -:  303:#if defined(_WIN32) || defined(__WIN32__) || defined(__WINDOWS__)
        -:  304:    #define ACUTEST_WIN_        1
        -:  305:    #include <windows.h>
        -:  306:    #include <io.h>
        -:  307:#endif
        -:  308:
        -:  309:#ifdef __cplusplus
        -:  310:    #include <exception>
        -:  311:#endif
        -:  312:
        -:  313:/* Load valgrind.h, if available. This allows to detect valgrind's presence via RUNNING_ON_VALGRIND. */
        -:  314:#ifdef __has_include
        -:  315:    #if __has_include(<valgrind.h>)
        -:  316:        #include <valgrind.h>
        -:  317:    #endif
        -:  318:#endif
        -:  319:
        -:  320:/* Enable the use of the non-standard keyword __attribute__ to silence warnings under some compilers */
        -:  321:#if defined(__GNUC__) || defined(__clang__)
        -:  322:    #define TEST_ATTRIBUTE_(attr)   __attribute__((attr))
        -:  323:#else
        -:  324:    #define TEST_ATTRIBUTE_(attr)
        -:  325:#endif
        -:  326:
        -:  327:/* Note our global private identifiers end with '_' to mitigate risk of clash
        -:  328: * with the unit tests implementation. */
        -:  329:
        -:  330:#ifdef __cplusplus
        -:  331:    extern "C" {
        -:  332:#endif
        -:  333:
        -:  334:#ifdef _MSC_VER
        -:  335:    /* In the multi-platform code like ours, we cannot use the non-standard
        -:  336:     * "safe" functions from Microsoft C lib like e.g. sprintf_s() instead of
        -:  337:     * standard sprintf(). Hence, lets disable the warning C4996. */
        -:  338:    #pragma warning(push)
        -:  339:    #pragma warning(disable: 4996)
        -:  340:#endif
        -:  341:
        -:  342:
        -:  343:struct test_ {
        -:  344:    const char* name;
        -:  345:    void (*func)(void);
        -:  346:};
        -:  347:
        -:  348:struct test_detail_ {
        -:  349:    unsigned char flags;
        -:  350:    double duration;
        -:  351:};
        -:  352:
        -:  353:enum {
        -:  354:    TEST_FLAG_RUN_ = 1 << 0,
        -:  355:    TEST_FLAG_SUCCESS_ = 1 << 1,
        -:  356:    TEST_FLAG_FAILURE_ = 1 << 2,
        -:  357:};
        -:  358:
        -:  359:extern const struct test_ test_list_[];
        -:  360:
        -:  361:int test_check_(int cond, const char* file, int line, const char* fmt, ...);
        -:  362:void test_case_(const char* fmt, ...);
        -:  363:void test_message_(const char* fmt, ...);
        -:  364:void test_dump_(const char* title, const void* addr, size_t size);
        -:  365:void test_abort_(void) TEST_ATTRIBUTE_(noreturn);
        -:  366:
        -:  367:
        -:  368:#ifndef TEST_NO_MAIN
        -:  369:
        -:  370:static char* test_argv0_ = NULL;
        -:  371:static size_t test_list_size_ = 0;
        -:  372:static struct test_detail_ *test_details_ = NULL;
        -:  373:static size_t test_count_ = 0;
        -:  374:static int test_no_exec_ = -1;
        -:  375:static int test_no_summary_ = 0;
        -:  376:static int test_tap_ = 0;
        -:  377:static int test_skip_mode_ = 0;
        -:  378:static int test_worker_ = 0;
        -:  379:static int test_worker_index_ = 0;
        -:  380:static int test_cond_failed_ = 0;
        -:  381:static int test_was_aborted_ = 0;
        -:  382:static FILE *test_xml_output_ = NULL;
        -:  383:
        -:  384:static int test_stat_failed_units_ = 0;
        -:  385:static int test_stat_run_units_ = 0;
        -:  386:
        -:  387:static const struct test_* test_current_unit_ = NULL;
        -:  388:static int test_current_index_ = 0;
        -:  389:static char test_case_name_[TEST_CASE_MAXSIZE] = "";
        -:  390:static int test_current_already_logged_ = 0;
        -:  391:static int test_case_current_already_logged_ = 0;
        -:  392:static int test_verbose_level_ = 2;
        -:  393:static int test_current_failures_ = 0;
        -:  394:static int test_colorize_ = 0;
        -:  395:static int test_timer_ = 0;
        -:  396:
        -:  397:static int test_abort_has_jmp_buf_ = 0;
        -:  398:static jmp_buf test_abort_jmp_buf_;
        -:  399:
        -:  400:
        -:  401:static void
        5:  402:test_cleanup_(void)
        -:  403:{
        5:  404:    free((void*) test_details_);
        5:  405:}
        -:  406:
        -:  407:static void
    #####:  408:test_exit_(int exit_code)
        -:  409:{
    #####:  410:    test_cleanup_();
    #####:  411:    exit(exit_code);
        -:  412:}
        -:  413:
        -:  414:#if defined ACUTEST_WIN_
        -:  415:    typedef LARGE_INTEGER test_timer_type_;
        -:  416:    static LARGE_INTEGER test_timer_freq_;
        -:  417:    static test_timer_type_ test_timer_start_;
        -:  418:    static test_timer_type_ test_timer_end_;
        -:  419:
        -:  420:    static void
        5:  421:    test_timer_init_(void)
        -:  422:    {
        5:  423:        QueryPerformanceFrequency(&test_timer_freq_);
        5:  424:    }
        -:  425:
        -:  426:    static void
       24:  427:    test_timer_get_time_(LARGE_INTEGER* ts)
        -:  428:    {
       24:  429:        QueryPerformanceCounter(ts);
       24:  430:    }
        -:  431:
        -:  432:    static double
        8:  433:    test_timer_diff_(LARGE_INTEGER start, LARGE_INTEGER end)
        -:  434:    {
        8:  435:        double duration = (double)(end.QuadPart - start.QuadPart);
        8:  436:        duration /= (double)test_timer_freq_.QuadPart;
        8:  437:        return duration;
        -:  438:    }
        -:  439:
        -:  440:    static void
    #####:  441:    test_timer_print_diff_(void)
        -:  442:    {
    #####:  443:        printf("%.6lf secs", test_timer_diff_(test_timer_start_, test_timer_end_));
    #####:  444:    }
        -:  445:#elif defined ACUTEST_HAS_POSIX_TIMER_
        -:  446:    static clockid_t test_timer_id_;
        -:  447:    typedef struct timespec test_timer_type_;
        -:  448:    static test_timer_type_ test_timer_start_;
        -:  449:    static test_timer_type_ test_timer_end_;
        -:  450:
        -:  451:    static void
        -:  452:    test_timer_init_(void)
        -:  453:    {
        -:  454:        if(test_timer_ == 1)
        -:  455:            test_timer_id_ = CLOCK_MONOTONIC;
        -:  456:        else if(test_timer_ == 2)
        -:  457:            test_timer_id_ = CLOCK_PROCESS_CPUTIME_ID;
        -:  458:    }
        -:  459:
        -:  460:    static void
        -:  461:    test_timer_get_time_(struct timespec* ts)
        -:  462:    {
        -:  463:        clock_gettime(test_timer_id_, ts);
        -:  464:    }
        -:  465:
        -:  466:    static double
        -:  467:    test_timer_diff_(struct timespec start, struct timespec end)
        -:  468:    {
        -:  469:        double endns;
        -:  470:        double startns;
        -:  471:
        -:  472:        endns = end.tv_sec;
        -:  473:        endns *= 1e9;
        -:  474:        endns += end.tv_nsec;
        -:  475:
        -:  476:        startns = start.tv_sec;
        -:  477:        startns *= 1e9;
        -:  478:        startns += start.tv_nsec;
        -:  479:
        -:  480:        return ((endns - startns)/ 1e9);
        -:  481:    }
        -:  482:
        -:  483:    static void
        -:  484:    test_timer_print_diff_(void)
        -:  485:    {
        -:  486:        printf("%.6lf secs",
        -:  487:            test_timer_diff_(test_timer_start_, test_timer_end_));
        -:  488:    }
        -:  489:#else
        -:  490:    typedef int test_timer_type_;
        -:  491:    static test_timer_type_ test_timer_start_;
        -:  492:    static test_timer_type_ test_timer_end_;
        -:  493:
        -:  494:    void
        -:  495:    test_timer_init_(void)
        -:  496:    {}
        -:  497:
        -:  498:    static void
        -:  499:    test_timer_get_time_(int* ts)
        -:  500:    {
        -:  501:        (void) ts;
        -:  502:    }
        -:  503:
        -:  504:    static double
        -:  505:    test_timer_diff_(int start, int end)
        -:  506:    {
        -:  507:        (void) start;
        -:  508:        (void) end;
        -:  509:        return 0.0;
        -:  510:    }
        -:  511:
        -:  512:    static void
        -:  513:    test_timer_print_diff_(void)
        -:  514:    {}
        -:  515:#endif
        -:  516:
        -:  517:#define TEST_COLOR_DEFAULT_             0
        -:  518:#define TEST_COLOR_GREEN_               1
        -:  519:#define TEST_COLOR_RED_                 2
        -:  520:#define TEST_COLOR_DEFAULT_INTENSIVE_   3
        -:  521:#define TEST_COLOR_GREEN_INTENSIVE_     4
        -:  522:#define TEST_COLOR_RED_INTENSIVE_       5
        -:  523:
        -:  524:static int TEST_ATTRIBUTE_(format (printf, 2, 3))
        9:  525:test_print_in_color_(int color, const char* fmt, ...)
        -:  526:{
        -:  527:    va_list args;
        -:  528:    char buffer[256];
        -:  529:    int n;
        -:  530:
        9:  531:    va_start(args, fmt);
        9:  532:    vsnprintf(buffer, sizeof(buffer), fmt, args);
        9:  533:    va_end(args);
        9:  534:    buffer[sizeof(buffer)-1] = '\0';
        -:  535:
        9:  536:    if(!test_colorize_) {
    #####:  537:        return printf("%s", buffer);
        -:  538:    }
        -:  539:
        -:  540:#if defined ACUTEST_UNIX_
        -:  541:    {
        -:  542:        const char* col_str;
        -:  543:        switch(color) {
        -:  544:            case TEST_COLOR_GREEN_:             col_str = "\033[0;32m"; break;
        -:  545:            case TEST_COLOR_RED_:               col_str = "\033[0;31m"; break;
        -:  546:            case TEST_COLOR_GREEN_INTENSIVE_:   col_str = "\033[1;32m"; break;
        -:  547:            case TEST_COLOR_RED_INTENSIVE_:     col_str = "\033[1;31m"; break;
        -:  548:            case TEST_COLOR_DEFAULT_INTENSIVE_: col_str = "\033[1m"; break;
        -:  549:            default:                            col_str = "\033[0m"; break;
        -:  550:        }
        -:  551:        printf("%s", col_str);
        -:  552:        n = printf("%s", buffer);
        -:  553:        printf("\033[0m");
        -:  554:        return n;
        -:  555:    }
        -:  556:#elif defined ACUTEST_WIN_
        -:  557:    {
        -:  558:        HANDLE h;
        -:  559:        CONSOLE_SCREEN_BUFFER_INFO info;
        -:  560:        WORD attr;
        -:  561:
        9:  562:        h = GetStdHandle(STD_OUTPUT_HANDLE);
        9:  563:        GetConsoleScreenBufferInfo(h, &info);
        -:  564:
        9:  565:        switch(color) {
    #####:  566:            case TEST_COLOR_GREEN_:             attr = FOREGROUND_GREEN; break;
    #####:  567:            case TEST_COLOR_RED_:               attr = FOREGROUND_RED; break;
        5:  568:            case TEST_COLOR_GREEN_INTENSIVE_:   attr = FOREGROUND_GREEN | FOREGROUND_INTENSITY; break;
    #####:  569:            case TEST_COLOR_RED_INTENSIVE_:     attr = FOREGROUND_RED | FOREGROUND_INTENSITY; break;
        4:  570:            case TEST_COLOR_DEFAULT_INTENSIVE_: attr = FOREGROUND_BLUE | FOREGROUND_GREEN | FOREGROUND_RED | FOREGROUND_INTENSITY; break;
    #####:  571:            default:                            attr = 0; break;
        -:  572:        }
        9:  573:        if(attr != 0)
        9:  574:            SetConsoleTextAttribute(h, attr);
        9:  575:        n = printf("%s", buffer);
        9:  576:        SetConsoleTextAttribute(h, info.wAttributes);
        9:  577:        return n;
        -:  578:    }
        -:  579:#else
        -:  580:    n = printf("%s", buffer);
        -:  581:    return n;
        -:  582:#endif
        -:  583:}
        -:  584:
        -:  585:static void
        4:  586:test_begin_test_line_(const struct test_* test)
        -:  587:{
        4:  588:    if(!test_tap_) {
        4:  589:        if(test_verbose_level_ >= 3) {
    #####:  590:            test_print_in_color_(TEST_COLOR_DEFAULT_INTENSIVE_, "Test %s:\n", test->name);
    #####:  591:            test_current_already_logged_++;
        4:  592:        } else if(test_verbose_level_ >= 1) {
        -:  593:            int n;
        -:  594:            char spaces[48];
        -:  595:
        4:  596:            n = test_print_in_color_(TEST_COLOR_DEFAULT_INTENSIVE_, "Test %s... ", test->name);
        4:  597:            memset(spaces, ' ', sizeof(spaces));
        4:  598:            if(n < (int) sizeof(spaces))
        4:  599:                printf("%.*s", (int) sizeof(spaces) - n, spaces);
        -:  600:        } else {
    #####:  601:            test_current_already_logged_ = 1;
        -:  602:        }
        -:  603:    }
        4:  604:}
        -:  605:
        -:  606:static void
        4:  607:test_finish_test_line_(int result)
        -:  608:{
        4:  609:    if(test_tap_) {
    #####:  610:        const char* str = (result == 0) ? "ok" : "not ok";
        -:  611:
    #####:  612:        printf("%s %d - %s\n", str, test_current_index_ + 1, test_current_unit_->name);
        -:  613:
    #####:  614:        if(result == 0  &&  test_timer_) {
    #####:  615:            printf("# Duration: ");
    #####:  616:            test_timer_print_diff_();
    #####:  617:            printf("\n");
        -:  618:        }
        -:  619:    } else {
       4*:  620:        int color = (result == 0) ? TEST_COLOR_GREEN_INTENSIVE_ : TEST_COLOR_RED_INTENSIVE_;
       4*:  621:        const char* str = (result == 0) ? "OK" : "FAILED";
        4:  622:        printf("[ ");
        4:  623:        test_print_in_color_(color, "%s", str);
        4:  624:        printf(" ]");
        -:  625:
        4:  626:        if(result == 0  &&  test_timer_) {
    #####:  627:            printf("  ");
    #####:  628:            test_timer_print_diff_();
        -:  629:        }
        -:  630:
        4:  631:        printf("\n");
        -:  632:    }
        4:  633:}
        -:  634:
        -:  635:static void
    #####:  636:test_line_indent_(int level)
        -:  637:{
        -:  638:    static const char spaces[] = "                ";
    #####:  639:    int n = level * 2;
        -:  640:
    #####:  641:    if(test_tap_  &&  n > 0) {
    #####:  642:        n--;
    #####:  643:        printf("#");
        -:  644:    }
        -:  645:
    #####:  646:    while(n > 16) {
    #####:  647:        printf("%s", spaces);
    #####:  648:        n -= 16;
        -:  649:    }
    #####:  650:    printf("%.*s", n, spaces);
    #####:  651:}
        -:  652:
        -:  653:int TEST_ATTRIBUTE_(format (printf, 4, 5))
       20:  654:test_check_(int cond, const char* file, int line, const char* fmt, ...)
        -:  655:{
        -:  656:    const char *result_str;
        -:  657:    int result_color;
        -:  658:    int verbose_level;
        -:  659:
       20:  660:    if(cond) {
       20:  661:        result_str = "ok";
       20:  662:        result_color = TEST_COLOR_GREEN_;
       20:  663:        verbose_level = 3;
        -:  664:    } else {
    #####:  665:        if(!test_current_already_logged_  &&  test_current_unit_ != NULL)
    #####:  666:            test_finish_test_line_(-1);
        -:  667:
    #####:  668:        result_str = "failed";
    #####:  669:        result_color = TEST_COLOR_RED_;
    #####:  670:        verbose_level = 2;
    #####:  671:        test_current_failures_++;
    #####:  672:        test_current_already_logged_++;
        -:  673:    }
        -:  674:
       20:  675:    if(test_verbose_level_ >= verbose_level) {
        -:  676:        va_list args;
        -:  677:
    #####:  678:        if(!test_case_current_already_logged_  &&  test_case_name_[0]) {
    #####:  679:            test_line_indent_(1);
    #####:  680:            test_print_in_color_(TEST_COLOR_DEFAULT_INTENSIVE_, "Case %s:\n", test_case_name_);
    #####:  681:            test_current_already_logged_++;
    #####:  682:            test_case_current_already_logged_++;
        -:  683:        }
        -:  684:
    #####:  685:        test_line_indent_(test_case_name_[0] ? 2 : 1);
    #####:  686:        if(file != NULL) {
        -:  687:#ifdef ACUTEST_WIN_
    #####:  688:            const char* lastsep1 = strrchr(file, '\\');
    #####:  689:            const char* lastsep2 = strrchr(file, '/');
    #####:  690:            if(lastsep1 == NULL)
    #####:  691:                lastsep1 = file-1;
    #####:  692:            if(lastsep2 == NULL)
    #####:  693:                lastsep2 = file-1;
    #####:  694:            file = (lastsep1 > lastsep2 ? lastsep1 : lastsep2) + 1;
        -:  695:#else
        -:  696:            const char* lastsep = strrchr(file, '/');
        -:  697:            if(lastsep != NULL)
        -:  698:                file = lastsep+1;
        -:  699:#endif
    #####:  700:            printf("%s:%d: Check ", file, line);
        -:  701:        }
        -:  702:
    #####:  703:        va_start(args, fmt);
    #####:  704:        vprintf(fmt, args);
    #####:  705:        va_end(args);
        -:  706:
    #####:  707:        printf("... ");
    #####:  708:        test_print_in_color_(result_color, "%s", result_str);
    #####:  709:        printf("\n");
    #####:  710:        test_current_already_logged_++;
        -:  711:    }
        -:  712:
       20:  713:    test_cond_failed_ = (cond == 0);
       20:  714:    return !test_cond_failed_;
        -:  715:}
        -:  716:
        -:  717:void TEST_ATTRIBUTE_(format (printf, 1, 2))
        4:  718:test_case_(const char* fmt, ...)
        -:  719:{
        -:  720:    va_list args;
        -:  721:
        4:  722:    if(test_verbose_level_ < 2)
       4*:  723:        return;
        -:  724:
        4:  725:    if(test_case_name_[0]) {
    #####:  726:        test_case_current_already_logged_ = 0;
    #####:  727:        test_case_name_[0] = '\0';
        -:  728:    }
        -:  729:
        4:  730:    if(fmt == NULL)
        4:  731:        return;
        -:  732:
    #####:  733:    va_start(args, fmt);
    #####:  734:    vsnprintf(test_case_name_, sizeof(test_case_name_) - 1, fmt, args);
    #####:  735:    va_end(args);
    #####:  736:    test_case_name_[sizeof(test_case_name_) - 1] = '\0';
        -:  737:
    #####:  738:    if(test_verbose_level_ >= 3) {
    #####:  739:        test_line_indent_(1);
    #####:  740:        test_print_in_color_(TEST_COLOR_DEFAULT_INTENSIVE_, "Case %s:\n", test_case_name_);
    #####:  741:        test_current_already_logged_++;
    #####:  742:        test_case_current_already_logged_++;
        -:  743:    }
        -:  744:}
        -:  745:
        -:  746:void TEST_ATTRIBUTE_(format (printf, 1, 2))
    #####:  747:test_message_(const char* fmt, ...)
        -:  748:{
        -:  749:    char buffer[TEST_MSG_MAXSIZE];
        -:  750:    char* line_beg;
        -:  751:    char* line_end;
        -:  752:    va_list args;
        -:  753:
    #####:  754:    if(test_verbose_level_ < 2)
    #####:  755:        return;
        -:  756:
        -:  757:    /* We allow extra message only when something is already wrong in the
        -:  758:     * current test. */
    #####:  759:    if(test_current_unit_ == NULL  ||  !test_cond_failed_)
    #####:  760:        return;
        -:  761:
    #####:  762:    va_start(args, fmt);
    #####:  763:    vsnprintf(buffer, TEST_MSG_MAXSIZE, fmt, args);
    #####:  764:    va_end(args);
    #####:  765:    buffer[TEST_MSG_MAXSIZE-1] = '\0';
        -:  766:
    #####:  767:    line_beg = buffer;
        -:  768:    while(1) {
    #####:  769:        line_end = strchr(line_beg, '\n');
    #####:  770:        if(line_end == NULL)
    #####:  771:            break;
    #####:  772:        test_line_indent_(test_case_name_[0] ? 3 : 2);
    #####:  773:        printf("%.*s\n", (int)(line_end - line_beg), line_beg);
    #####:  774:        line_beg = line_end + 1;
        -:  775:    }
    #####:  776:    if(line_beg[0] != '\0') {
    #####:  777:        test_line_indent_(test_case_name_[0] ? 3 : 2);
    #####:  778:        printf("%s\n", line_beg);
        -:  779:    }
        -:  780:}
        -:  781:
        -:  782:void
    #####:  783:test_dump_(const char* title, const void* addr, size_t size)
        -:  784:{
        -:  785:    static const size_t BYTES_PER_LINE = 16;
        -:  786:    size_t line_beg;
    #####:  787:    size_t truncate = 0;
        -:  788:
    #####:  789:    if(test_verbose_level_ < 2)
    #####:  790:        return;
        -:  791:
        -:  792:    /* We allow extra message only when something is already wrong in the
        -:  793:     * current test. */
    #####:  794:    if(test_current_unit_ == NULL  ||  !test_cond_failed_)
    #####:  795:        return;
        -:  796:
    #####:  797:    if(size > TEST_DUMP_MAXSIZE) {
    #####:  798:        truncate = size - TEST_DUMP_MAXSIZE;
    #####:  799:        size = TEST_DUMP_MAXSIZE;
        -:  800:    }
        -:  801:
    #####:  802:    test_line_indent_(test_case_name_[0] ? 3 : 2);
    #####:  803:    printf((title[strlen(title)-1] == ':') ? "%s\n" : "%s:\n", title);
        -:  804:
    #####:  805:    for(line_beg = 0; line_beg < size; line_beg += BYTES_PER_LINE) {
    #####:  806:        size_t line_end = line_beg + BYTES_PER_LINE;
        -:  807:        size_t off;
        -:  808:
    #####:  809:        test_line_indent_(test_case_name_[0] ? 4 : 3);
    #####:  810:        printf("%08lx: ", (unsigned long)line_beg);
    #####:  811:        for(off = line_beg; off < line_end; off++) {
    #####:  812:            if(off < size)
    #####:  813:                printf(" %02x", ((const unsigned char*)addr)[off]);
        -:  814:            else
    #####:  815:                printf("   ");
        -:  816:        }
        -:  817:
    #####:  818:        printf("  ");
    #####:  819:        for(off = line_beg; off < line_end; off++) {
    #####:  820:            unsigned char byte = ((const unsigned char*)addr)[off];
    #####:  821:            if(off < size)
    #####:  822:                printf("%c", (iscntrl(byte) ? '.' : byte));
        -:  823:            else
    #####:  824:                break;
        -:  825:        }
        -:  826:
    #####:  827:        printf("\n");
        -:  828:    }
        -:  829:
    #####:  830:    if(truncate > 0) {
    #####:  831:        test_line_indent_(test_case_name_[0] ? 4 : 3);
    #####:  832:        printf("           ... (and more %u bytes)\n", (unsigned) truncate);
        -:  833:    }
        -:  834:}
        -:  835:
        -:  836:/* This is called just before each test */
        -:  837:static void
        4:  838:test_init_(const char *test_name)
        -:  839:{
        -:  840:#ifdef TEST_INIT
        -:  841:    TEST_INIT
        -:  842:    ; /* Allow for a single unterminated function call */
        -:  843:#endif
        -:  844:
        -:  845:    /* Suppress any warnings about unused variable. */
        -:  846:    (void) test_name;
        4:  847:}
        -:  848:
        -:  849:/* This is called after each test */
        -:  850:static void
        4:  851:test_fini_(const char *test_name)
        -:  852:{
        -:  853:#ifdef TEST_FINI
        -:  854:    TEST_FINI
        -:  855:    ; /* Allow for a single unterminated function call */
        -:  856:#endif
        -:  857:
        -:  858:    /* Suppress any warnings about unused variable. */
        -:  859:    (void) test_name;
        4:  860:}
        -:  861:
        -:  862:void
    #####:  863:test_abort_(void)
        -:  864:{
    #####:  865:    if(test_abort_has_jmp_buf_) {
    #####:  866:        longjmp(test_abort_jmp_buf_, 1);
        -:  867:    } else {
    #####:  868:        if(test_current_unit_ != NULL)
    #####:  869:            test_fini_(test_current_unit_->name);
    #####:  870:        abort();
        -:  871:    }
        -:  872:}
        -:  873:
        -:  874:static void
    #####:  875:test_list_names_(void)
        -:  876:{
        -:  877:    const struct test_* test;
        -:  878:
    #####:  879:    printf("Unit tests:\n");
    #####:  880:    for(test = &test_list_[0]; test->func != NULL; test++)
    #####:  881:        printf("  %s\n", test->name);
    #####:  882:}
        -:  883:
        -:  884:static void
        8:  885:test_remember_(int i)
        -:  886:{
        8:  887:    if(test_details_[i].flags & TEST_FLAG_RUN_)
    #####:  888:        return;
        -:  889:
        8:  890:    test_details_[i].flags |= TEST_FLAG_RUN_;
        8:  891:    test_count_++;
        -:  892:}
        -:  893:
        -:  894:static void
        8:  895:test_set_success_(int i, int success)
        -:  896:{
       8*:  897:    test_details_[i].flags |= success ? TEST_FLAG_SUCCESS_ : TEST_FLAG_FAILURE_;
        8:  898:}
        -:  899:
        -:  900:static void
        8:  901:test_set_duration_(int i, double duration)
        -:  902:{
        8:  903:    test_details_[i].duration = duration;
        8:  904:}
        -:  905:
        -:  906:static int
    #####:  907:test_name_contains_word_(const char* name, const char* pattern)
        -:  908:{
        -:  909:    static const char word_delim[] = " \t-_/.,:;";
        -:  910:    const char* substr;
        -:  911:    size_t pattern_len;
        -:  912:
    #####:  913:    pattern_len = strlen(pattern);
        -:  914:
    #####:  915:    substr = strstr(name, pattern);
    #####:  916:    while(substr != NULL) {
    #####:  917:        int starts_on_word_boundary = (substr == name || strchr(word_delim, substr[-1]) != NULL);
    #####:  918:        int ends_on_word_boundary = (substr[pattern_len] == '\0' || strchr(word_delim, substr[pattern_len]) != NULL);
        -:  919:
    #####:  920:        if(starts_on_word_boundary && ends_on_word_boundary)
    #####:  921:            return 1;
        -:  922:
    #####:  923:        substr = strstr(substr+1, pattern);
        -:  924:    }
        -:  925:
    #####:  926:    return 0;
        -:  927:}
        -:  928:
        -:  929:static int
        4:  930:test_lookup_(const char* pattern)
        -:  931:{
        -:  932:    int i;
        4:  933:    int n = 0;
        -:  934:
        -:  935:    /* Try exact match. */
       10:  936:    for(i = 0; i < (int) test_list_size_; i++) {
       10:  937:        if(strcmp(test_list_[i].name, pattern) == 0) {
        4:  938:            test_remember_(i);
        4:  939:            n++;
        4:  940:            break;
        -:  941:        }
        -:  942:    }
        4:  943:    if(n > 0)
        4:  944:        return n;
        -:  945:
        -:  946:    /* Try word match. */
    #####:  947:    for(i = 0; i < (int) test_list_size_; i++) {
    #####:  948:        if(test_name_contains_word_(test_list_[i].name, pattern)) {
    #####:  949:            test_remember_(i);
    #####:  950:            n++;
        -:  951:        }
        -:  952:    }
    #####:  953:    if(n > 0)
    #####:  954:        return n;
        -:  955:
        -:  956:    /* Try relaxed match. */
    #####:  957:    for(i = 0; i < (int) test_list_size_; i++) {
    #####:  958:        if(strstr(test_list_[i].name, pattern) != NULL) {
    #####:  959:            test_remember_(i);
    #####:  960:            n++;
        -:  961:        }
        -:  962:    }
        -:  963:
    #####:  964:    return n;
        -:  965:}
        -:  966:
        -:  967:
        -:  968:/* Called if anything goes bad in Acutest, or if the unit test ends in other
        -:  969: * way then by normal returning from its function (e.g. exception or some
        -:  970: * abnormal child process termination). */
        -:  971:static void TEST_ATTRIBUTE_(format (printf, 1, 2))
    #####:  972:test_error_(const char* fmt, ...)
        -:  973:{
    #####:  974:    if(test_verbose_level_ == 0)
    #####:  975:        return;
        -:  976:
    #####:  977:    if(test_verbose_level_ >= 2) {
        -:  978:        va_list args;
        -:  979:
    #####:  980:        test_line_indent_(1);
    #####:  981:        if(test_verbose_level_ >= 3)
    #####:  982:            test_print_in_color_(TEST_COLOR_RED_INTENSIVE_, "ERROR: ");
    #####:  983:        va_start(args, fmt);
    #####:  984:        vprintf(fmt, args);
    #####:  985:        va_end(args);
    #####:  986:        printf("\n");
        -:  987:    }
        -:  988:
    #####:  989:    if(test_verbose_level_ >= 3) {
    #####:  990:        printf("\n");
        -:  991:    }
        -:  992:}
        -:  993:
        -:  994:/* Call directly the given test unit function. */
        -:  995:static int
        4:  996:test_do_run_(const struct test_* test, int index)
        -:  997:{
        4:  998:    int status = -1;
        -:  999:
        4: 1000:    test_was_aborted_ = 0;
        4: 1001:    test_current_unit_ = test;
        4: 1002:    test_current_index_ = index;
        4: 1003:    test_current_failures_ = 0;
        4: 1004:    test_current_already_logged_ = 0;
        4: 1005:    test_cond_failed_ = 0;
        -: 1006:
        -: 1007:#ifdef __cplusplus
        -: 1008:    try {
        -: 1009:#endif
        4: 1010:        test_init_(test->name);
        4: 1011:        test_begin_test_line_(test);
        -: 1012:
        -: 1013:        /* This is good to do in case the test unit crashes. */
        4: 1014:        fflush(stdout);
        4: 1015:        fflush(stderr);
        -: 1016:
        4: 1017:        if(!test_worker_) {
    #####: 1018:            test_abort_has_jmp_buf_ = 1;
    #####: 1019:            if(setjmp(test_abort_jmp_buf_) != 0) {
    #####: 1020:                test_was_aborted_ = 1;
    #####: 1021:                goto aborted;
        -: 1022:            }
        -: 1023:        }
        -: 1024:
        4: 1025:        test_timer_get_time_(&test_timer_start_);
        4: 1026:        test->func();
        4: 1027:aborted:
        4: 1028:        test_abort_has_jmp_buf_ = 0;
        4: 1029:        test_timer_get_time_(&test_timer_end_);
        -: 1030:
        4: 1031:        if(test_verbose_level_ >= 3) {
    #####: 1032:            test_line_indent_(1);
    #####: 1033:            if(test_current_failures_ == 0) {
    #####: 1034:                test_print_in_color_(TEST_COLOR_GREEN_INTENSIVE_, "SUCCESS: ");
    #####: 1035:                printf("All conditions have passed.\n");
        -: 1036:
    #####: 1037:                if(test_timer_) {
    #####: 1038:                    test_line_indent_(1);
    #####: 1039:                    printf("Duration: ");
    #####: 1040:                    test_timer_print_diff_();
    #####: 1041:                    printf("\n");
        -: 1042:                }
        -: 1043:            } else {
    #####: 1044:                test_print_in_color_(TEST_COLOR_RED_INTENSIVE_, "FAILED: ");
    #####: 1045:                if(!test_was_aborted_) {
    #####: 1046:                    printf("%d condition%s %s failed.\n",
        -: 1047:                            test_current_failures_,
    #####: 1048:                            (test_current_failures_ == 1) ? "" : "s",
    #####: 1049:                            (test_current_failures_ == 1) ? "has" : "have");
        -: 1050:                } else {
    #####: 1051:                    printf("Aborted.\n");
        -: 1052:                }
        -: 1053:            }
    #####: 1054:            printf("\n");
        4: 1055:        } else if(test_verbose_level_ >= 1 && test_current_failures_ == 0) {
        4: 1056:            test_finish_test_line_(0);
        -: 1057:        }
        -: 1058:
       4*: 1059:        status = (test_current_failures_ == 0) ? 0 : -1;
        -: 1060:
        -: 1061:#ifdef __cplusplus
        -: 1062:    } catch(std::exception& e) {
        -: 1063:        const char* what = e.what();
        -: 1064:        test_check_(0, NULL, 0, "Threw std::exception");
        -: 1065:        if(what != NULL)
        -: 1066:            test_message_("std::exception::what(): %s", what);
        -: 1067:
        -: 1068:        if(test_verbose_level_ >= 3) {
        -: 1069:            test_line_indent_(1);
        -: 1070:            test_print_in_color_(TEST_COLOR_RED_INTENSIVE_, "FAILED: ");
        -: 1071:            printf("C++ exception.\n\n");
        -: 1072:        }
        -: 1073:    } catch(...) {
        -: 1074:        test_check_(0, NULL, 0, "Threw an exception");
        -: 1075:
        -: 1076:        if(test_verbose_level_ >= 3) {
        -: 1077:            test_line_indent_(1);
        -: 1078:            test_print_in_color_(TEST_COLOR_RED_INTENSIVE_, "FAILED: ");
        -: 1079:            printf("C++ exception.\n\n");
        -: 1080:        }
        -: 1081:    }
        -: 1082:#endif
        -: 1083:
        4: 1084:    test_fini_(test->name);
        4: 1085:    test_case_(NULL);
        4: 1086:    test_current_unit_ = NULL;
        -: 1087:
        4: 1088:    return status;
        -: 1089:}
        -: 1090:
        -: 1091:/* Trigger the unit test. If possible (and not suppressed) it starts a child
        -: 1092: * process who calls test_do_run_(), otherwise it calls test_do_run_()
        -: 1093: * directly. */
        -: 1094:static void
        8: 1095:test_run_(const struct test_* test, int index, int master_index)
        -: 1096:{
        8: 1097:    int failed = 1;
        -: 1098:    test_timer_type_ start, end;
        -: 1099:
        8: 1100:    test_current_unit_ = test;
        8: 1101:    test_current_already_logged_ = 0;
        8: 1102:    test_timer_get_time_(&start);
        -: 1103:
        8: 1104:    if(!test_no_exec_) {
        -: 1105:
        -: 1106:#if defined(ACUTEST_UNIX_)
        -: 1107:
        -: 1108:        pid_t pid;
        -: 1109:        int exit_code;
        -: 1110:
        -: 1111:        /* Make sure the child starts with empty I/O buffers. */
        -: 1112:        fflush(stdout);
        -: 1113:        fflush(stderr);
        -: 1114:
        -: 1115:        pid = fork();
        -: 1116:        if(pid == (pid_t)-1) {
        -: 1117:            test_error_("Cannot fork. %s [%d]", strerror(errno), errno);
        -: 1118:            failed = 1;
        -: 1119:        } else if(pid == 0) {
        -: 1120:            /* Child: Do the test. */
        -: 1121:            test_worker_ = 1;
        -: 1122:            failed = (test_do_run_(test, index) != 0);
        -: 1123:            test_exit_(failed ? 1 : 0);
        -: 1124:        } else {
        -: 1125:            /* Parent: Wait until child terminates and analyze its exit code. */
        -: 1126:            waitpid(pid, &exit_code, 0);
        -: 1127:            if(WIFEXITED(exit_code)) {
        -: 1128:                switch(WEXITSTATUS(exit_code)) {
        -: 1129:                    case 0:   failed = 0; break;   /* test has passed. */
        -: 1130:                    case 1:   /* noop */ break;    /* "normal" failure. */
        -: 1131:                    default:  test_error_("Unexpected exit code [%d]", WEXITSTATUS(exit_code));
        -: 1132:                }
        -: 1133:            } else if(WIFSIGNALED(exit_code)) {
        -: 1134:                char tmp[32];
        -: 1135:                const char* signame;
        -: 1136:                switch(WTERMSIG(exit_code)) {
        -: 1137:                    case SIGINT:  signame = "SIGINT"; break;
        -: 1138:                    case SIGHUP:  signame = "SIGHUP"; break;
        -: 1139:                    case SIGQUIT: signame = "SIGQUIT"; break;
        -: 1140:                    case SIGABRT: signame = "SIGABRT"; break;
        -: 1141:                    case SIGKILL: signame = "SIGKILL"; break;
        -: 1142:                    case SIGSEGV: signame = "SIGSEGV"; break;
        -: 1143:                    case SIGILL:  signame = "SIGILL"; break;
        -: 1144:                    case SIGTERM: signame = "SIGTERM"; break;
        -: 1145:                    default:      sprintf(tmp, "signal %d", WTERMSIG(exit_code)); signame = tmp; break;
        -: 1146:                }
        -: 1147:                test_error_("Test interrupted by %s.", signame);
        -: 1148:            } else {
        -: 1149:                test_error_("Test ended in an unexpected way [%d].", exit_code);
        -: 1150:            }
        -: 1151:        }
        -: 1152:
        -: 1153:#elif defined(ACUTEST_WIN_)
        -: 1154:
        4: 1155:        char buffer[512] = {0};
        -: 1156:        STARTUPINFOA startupInfo;
        -: 1157:        PROCESS_INFORMATION processInfo;
        -: 1158:        DWORD exitCode;
        -: 1159:
        -: 1160:        /* Windows has no fork(). So we propagate all info into the child
        -: 1161:         * through a command line arguments. */
      12*: 1162:        _snprintf(buffer, sizeof(buffer)-1,
        -: 1163:                 "%s --worker=%d %s --no-exec --no-summary %s --verbose=%d --color=%s -- \"%s\"",
        4: 1164:                 test_argv0_, index, test_timer_ ? "--time" : "",
        4: 1165:                 test_tap_ ? "--tap" : "", test_verbose_level_,
        4: 1166:                 test_colorize_ ? "always" : "never",
        -: 1167:                 test->name);
        4: 1168:        memset(&startupInfo, 0, sizeof(startupInfo));
        4: 1169:        startupInfo.cb = sizeof(STARTUPINFO);
        4: 1170:        if(CreateProcessA(NULL, buffer, NULL, NULL, FALSE, 0, NULL, NULL, &startupInfo, &processInfo)) {
        4: 1171:            WaitForSingleObject(processInfo.hProcess, INFINITE);
        4: 1172:            GetExitCodeProcess(processInfo.hProcess, &exitCode);
        4: 1173:            CloseHandle(processInfo.hThread);
        4: 1174:            CloseHandle(processInfo.hProcess);
        4: 1175:            failed = (exitCode != 0);
        4: 1176:            if(exitCode > 1) {
    #####: 1177:                switch(exitCode) {
    #####: 1178:                    case 3:             test_error_("Aborted."); break;
    #####: 1179:                    case 0xC0000005:    test_error_("Access violation."); break;
    #####: 1180:                    default:            test_error_("Test ended in an unexpected way [%lu].", exitCode); break;
        -: 1181:                }
        4: 1182:            }
        -: 1183:        } else {
    #####: 1184:            test_error_("Cannot create unit test subprocess [%ld].", GetLastError());
    #####: 1185:            failed = 1;
        -: 1186:        }
        -: 1187:
        -: 1188:#else
        -: 1189:
        -: 1190:        /* A platform where we don't know how to run child process. */
        -: 1191:        failed = (test_do_run_(test, index) != 0);
        -: 1192:
        -: 1193:#endif
        -: 1194:
        -: 1195:    } else {
        -: 1196:        /* Child processes suppressed through --no-exec. */
        4: 1197:        failed = (test_do_run_(test, index) != 0);
        -: 1198:    }
        8: 1199:    test_timer_get_time_(&end);
        -: 1200:
        8: 1201:    test_current_unit_ = NULL;
        -: 1202:
        8: 1203:    test_stat_run_units_++;
        8: 1204:    if(failed)
    #####: 1205:        test_stat_failed_units_++;
        -: 1206:
        8: 1207:    test_set_success_(master_index, !failed);
        8: 1208:    test_set_duration_(master_index, test_timer_diff_(start, end));
        8: 1209:}
        -: 1210:
        -: 1211:#if defined(ACUTEST_WIN_)
        -: 1212:/* Callback for SEH events. */
        -: 1213:static LONG CALLBACK
    #####: 1214:test_seh_exception_filter_(EXCEPTION_POINTERS *ptrs)
        -: 1215:{
    #####: 1216:    test_check_(0, NULL, 0, "Unhandled SEH exception");
    #####: 1217:    test_message_("Exception code:    0x%08lx", ptrs->ExceptionRecord->ExceptionCode);
    #####: 1218:    test_message_("Exception address: 0x%p", ptrs->ExceptionRecord->ExceptionAddress);
        -: 1219:
    #####: 1220:    fflush(stdout);
    #####: 1221:    fflush(stderr);
        -: 1222:
    #####: 1223:    return EXCEPTION_EXECUTE_HANDLER;
        -: 1224:}
        -: 1225:#endif
        -: 1226:
        -: 1227:
        -: 1228:#define TEST_CMDLINE_OPTFLAG_OPTIONALARG_   0x0001
        -: 1229:#define TEST_CMDLINE_OPTFLAG_REQUIREDARG_   0x0002
        -: 1230:
        -: 1231:#define TEST_CMDLINE_OPTID_NONE_            0
        -: 1232:#define TEST_CMDLINE_OPTID_UNKNOWN_         (-0x7fffffff + 0)
        -: 1233:#define TEST_CMDLINE_OPTID_MISSINGARG_      (-0x7fffffff + 1)
        -: 1234:#define TEST_CMDLINE_OPTID_BOGUSARG_        (-0x7fffffff + 2)
        -: 1235:
        -: 1236:typedef struct TEST_CMDLINE_OPTION_ {
        -: 1237:    char shortname;
        -: 1238:    const char* longname;
        -: 1239:    int id;
        -: 1240:    unsigned flags;
        -: 1241:} TEST_CMDLINE_OPTION_;
        -: 1242:
        -: 1243:static int
    #####: 1244:test_cmdline_handle_short_opt_group_(const TEST_CMDLINE_OPTION_* options,
        -: 1245:                    const char* arggroup,
        -: 1246:                    int (*callback)(int /*optval*/, const char* /*arg*/))
        -: 1247:{
        -: 1248:    const TEST_CMDLINE_OPTION_* opt;
        -: 1249:    int i;
    #####: 1250:    int ret = 0;
        -: 1251:
    #####: 1252:    for(i = 0; arggroup[i] != '\0'; i++) {
    #####: 1253:        for(opt = options; opt->id != 0; opt++) {
    #####: 1254:            if(arggroup[i] == opt->shortname)
    #####: 1255:                break;
        -: 1256:        }
        -: 1257:
    #####: 1258:        if(opt->id != 0  &&  !(opt->flags & TEST_CMDLINE_OPTFLAG_REQUIREDARG_)) {
    #####: 1259:            ret = callback(opt->id, NULL);
        -: 1260:        } else {
        -: 1261:            /* Unknown option. */
        -: 1262:            char badoptname[3];
    #####: 1263:            badoptname[0] = '-';
    #####: 1264:            badoptname[1] = arggroup[i];
    #####: 1265:            badoptname[2] = '\0';
    #####: 1266:            ret = callback((opt->id != 0 ? TEST_CMDLINE_OPTID_MISSINGARG_ : TEST_CMDLINE_OPTID_UNKNOWN_),
        -: 1267:                            badoptname);
        -: 1268:        }
        -: 1269:
    #####: 1270:        if(ret != 0)
    #####: 1271:            break;
        -: 1272:    }
        -: 1273:
    #####: 1274:    return ret;
        -: 1275:}
        -: 1276:
        -: 1277:#define TEST_CMDLINE_AUXBUF_SIZE_  32
        -: 1278:
        -: 1279:static int
        5: 1280:test_cmdline_read_(const TEST_CMDLINE_OPTION_* options, int argc, char** argv,
        -: 1281:                    int (*callback)(int /*optval*/, const char* /*arg*/))
        -: 1282:{
        -: 1283:
        -: 1284:    const TEST_CMDLINE_OPTION_* opt;
        -: 1285:    char auxbuf[TEST_CMDLINE_AUXBUF_SIZE_+1];
        5: 1286:    int after_doubledash = 0;
        5: 1287:    int i = 1;
        5: 1288:    int ret = 0;
        -: 1289:
        5: 1290:    auxbuf[TEST_CMDLINE_AUXBUF_SIZE_] = '\0';
        -: 1291:
       33: 1292:    while(i < argc) {
       28: 1293:        if(after_doubledash  ||  strcmp(argv[i], "-") == 0) {
        -: 1294:            /* Non-option argument. */
        4: 1295:            ret = callback(TEST_CMDLINE_OPTID_NONE_, argv[i]);
       24: 1296:        } else if(strcmp(argv[i], "--") == 0) {
        -: 1297:            /* End of options. All the remaining members are non-option arguments. */
        4: 1298:            after_doubledash = 1;
       20: 1299:        } else if(argv[i][0] != '-') {
        -: 1300:            /* Non-option argument. */
    #####: 1301:            ret = callback(TEST_CMDLINE_OPTID_NONE_, argv[i]);
        -: 1302:        } else {
      172: 1303:            for(opt = options; opt->id != 0; opt++) {
      324: 1304:                if(opt->longname != NULL  &&  strncmp(argv[i], "--", 2) == 0) {
      172: 1305:                    size_t len = strlen(opt->longname);
      172: 1306:                    if(strncmp(argv[i]+2, opt->longname, len) == 0) {
        -: 1307:                        /* Regular long option. */
       20: 1308:                        if(argv[i][2+len] == '\0') {
        -: 1309:                            /* with no argument provided. */
        8: 1310:                            if(!(opt->flags & TEST_CMDLINE_OPTFLAG_REQUIREDARG_))
        8: 1311:                                ret = callback(opt->id, NULL);
        -: 1312:                            else
    #####: 1313:                                ret = callback(TEST_CMDLINE_OPTID_MISSINGARG_, argv[i]);
        8: 1314:                            break;
       12: 1315:                        } else if(argv[i][2+len] == '=') {
        -: 1316:                            /* with an argument provided. */
       12: 1317:                            if(opt->flags & (TEST_CMDLINE_OPTFLAG_OPTIONALARG_ | TEST_CMDLINE_OPTFLAG_REQUIREDARG_)) {
       12: 1318:                                ret = callback(opt->id, argv[i]+2+len+1);
        -: 1319:                            } else {
    #####: 1320:                                sprintf(auxbuf, "--%s", opt->longname);
    #####: 1321:                                ret = callback(TEST_CMDLINE_OPTID_BOGUSARG_, auxbuf);
        -: 1322:                            }
       12: 1323:                            break;
        -: 1324:                        } else {
    #####: 1325:                            continue;
        -: 1326:                        }
        -: 1327:                    }
    #####: 1328:                } else if(opt->shortname != '\0'  &&  argv[i][0] == '-') {
    #####: 1329:                    if(argv[i][1] == opt->shortname) {
        -: 1330:                        /* Regular short option. */
    #####: 1331:                        if(opt->flags & TEST_CMDLINE_OPTFLAG_REQUIREDARG_) {
    #####: 1332:                            if(argv[i][2] != '\0')
    #####: 1333:                                ret = callback(opt->id, argv[i]+2);
    #####: 1334:                            else if(i+1 < argc)
    #####: 1335:                                ret = callback(opt->id, argv[++i]);
        -: 1336:                            else
    #####: 1337:                                ret = callback(TEST_CMDLINE_OPTID_MISSINGARG_, argv[i]);
    #####: 1338:                            break;
        -: 1339:                        } else {
    #####: 1340:                            ret = callback(opt->id, NULL);
        -: 1341:
        -: 1342:                            /* There might be more (argument-less) short options
        -: 1343:                             * grouped together. */
    #####: 1344:                            if(ret == 0  &&  argv[i][2] != '\0')
    #####: 1345:                                ret = test_cmdline_handle_short_opt_group_(options, argv[i]+2, callback);
    #####: 1346:                            break;
        -: 1347:                        }
        -: 1348:                    }
        -: 1349:                }
        -: 1350:            }
        -: 1351:
       20: 1352:            if(opt->id == 0) {  /* still not handled? */
    #####: 1353:                if(argv[i][0] != '-') {
        -: 1354:                    /* Non-option argument. */
    #####: 1355:                    ret = callback(TEST_CMDLINE_OPTID_NONE_, argv[i]);
        -: 1356:                } else {
        -: 1357:                    /* Unknown option. */
    #####: 1358:                    char* badoptname = argv[i];
        -: 1359:
    #####: 1360:                    if(strncmp(badoptname, "--", 2) == 0) {
        -: 1361:                        /* Strip any argument from the long option. */
    #####: 1362:                        char* assignment = strchr(badoptname, '=');
    #####: 1363:                        if(assignment != NULL) {
    #####: 1364:                            size_t len = assignment - badoptname;
    #####: 1365:                            if(len > TEST_CMDLINE_AUXBUF_SIZE_)
    #####: 1366:                                len = TEST_CMDLINE_AUXBUF_SIZE_;
    #####: 1367:                            strncpy(auxbuf, badoptname, len);
    #####: 1368:                            auxbuf[len] = '\0';
    #####: 1369:                            badoptname = auxbuf;
        -: 1370:                        }
        -: 1371:                    }
        -: 1372:
    #####: 1373:                    ret = callback(TEST_CMDLINE_OPTID_UNKNOWN_, badoptname);
        -: 1374:                }
        -: 1375:            }
        -: 1376:        }
        -: 1377:
       28: 1378:        if(ret != 0)
    #####: 1379:            return ret;
       28: 1380:        i++;
        -: 1381:    }
        -: 1382:
        5: 1383:    return ret;
        -: 1384:}
        -: 1385:
        -: 1386:static void
    #####: 1387:test_help_(void)
        -: 1388:{
    #####: 1389:    printf("Usage: %s [options] [test...]\n", test_argv0_);
    #####: 1390:    printf("\n");
    #####: 1391:    printf("Run the specified unit tests; or if the option '--skip' is used, run all\n");
    #####: 1392:    printf("tests in the suite but those listed.  By default, if no tests are specified\n");
    #####: 1393:    printf("on the command line, all unit tests in the suite are run.\n");
    #####: 1394:    printf("\n");
    #####: 1395:    printf("Options:\n");
    #####: 1396:    printf("  -s, --skip            Execute all unit tests but the listed ones\n");
    #####: 1397:    printf("      --exec[=WHEN]     If supported, execute unit tests as child processes\n");
    #####: 1398:    printf("                          (WHEN is one of 'auto', 'always', 'never')\n");
    #####: 1399:    printf("  -E, --no-exec         Same as --exec=never\n");
        -: 1400:#if defined ACUTEST_WIN_
    #####: 1401:    printf("  -t, --time            Measure test duration\n");
        -: 1402:#elif defined ACUTEST_HAS_POSIX_TIMER_
        -: 1403:    printf("  -t, --time            Measure test duration (real time)\n");
        -: 1404:    printf("      --time=TIMER      Measure test duration, using given timer\n");
        -: 1405:    printf("                          (TIMER is one of 'real', 'cpu')\n");
        -: 1406:#endif
    #####: 1407:    printf("      --no-summary      Suppress printing of test results summary\n");
    #####: 1408:    printf("      --tap             Produce TAP-compliant output\n");
    #####: 1409:    printf("                          (See https://testanything.org/)\n");
    #####: 1410:    printf("  -x, --xml-output=FILE Enable XUnit output to the given file\n");
    #####: 1411:    printf("  -l, --list            List unit tests in the suite and exit\n");
    #####: 1412:    printf("  -v, --verbose         Make output more verbose\n");
    #####: 1413:    printf("      --verbose=LEVEL   Set verbose level to LEVEL:\n");
    #####: 1414:    printf("                          0 ... Be silent\n");
    #####: 1415:    printf("                          1 ... Output one line per test (and summary)\n");
    #####: 1416:    printf("                          2 ... As 1 and failed conditions (this is default)\n");
    #####: 1417:    printf("                          3 ... As 1 and all conditions (and extended summary)\n");
    #####: 1418:    printf("  -q, --quiet           Same as --verbose=0\n");
    #####: 1419:    printf("      --color[=WHEN]    Enable colorized output\n");
    #####: 1420:    printf("                          (WHEN is one of 'auto', 'always', 'never')\n");
    #####: 1421:    printf("      --no-color        Same as --color=never\n");
    #####: 1422:    printf("  -h, --help            Display this help and exit\n");
        -: 1423:
    #####: 1424:    if(test_list_size_ < 16) {
    #####: 1425:        printf("\n");
    #####: 1426:        test_list_names_();
        -: 1427:    }
    #####: 1428:}
        -: 1429:
        -: 1430:static const TEST_CMDLINE_OPTION_ test_cmdline_options_[] = {
        -: 1431:    { 's',  "skip",         's', 0 },
        -: 1432:    {  0,   "exec",         'e', TEST_CMDLINE_OPTFLAG_OPTIONALARG_ },
        -: 1433:    { 'E',  "no-exec",      'E', 0 },
        -: 1434:#if defined ACUTEST_WIN_
        -: 1435:    { 't',  "time",         't', 0 },
        -: 1436:    {  0,   "timer",        't', 0 },   /* kept for compatibility */
        -: 1437:#elif defined ACUTEST_HAS_POSIX_TIMER_
        -: 1438:    { 't',  "time",         't', TEST_CMDLINE_OPTFLAG_OPTIONALARG_ },
        -: 1439:    {  0,   "timer",        't', TEST_CMDLINE_OPTFLAG_OPTIONALARG_ },  /* kept for compatibility */
        -: 1440:#endif
        -: 1441:    {  0,   "no-summary",   'S', 0 },
        -: 1442:    {  0,   "tap",          'T', 0 },
        -: 1443:    { 'l',  "list",         'l', 0 },
        -: 1444:    { 'v',  "verbose",      'v', TEST_CMDLINE_OPTFLAG_OPTIONALARG_ },
        -: 1445:    { 'q',  "quiet",        'q', 0 },
        -: 1446:    {  0,   "color",        'c', TEST_CMDLINE_OPTFLAG_OPTIONALARG_ },
        -: 1447:    {  0,   "no-color",     'C', 0 },
        -: 1448:    { 'h',  "help",         'h', 0 },
        -: 1449:    {  0,   "worker",       'w', TEST_CMDLINE_OPTFLAG_REQUIREDARG_ },  /* internal */
        -: 1450:    { 'x',  "xml-output",   'x', TEST_CMDLINE_OPTFLAG_REQUIREDARG_ },
        -: 1451:    {  0,   NULL,            0,  0 }
        -: 1452:};
        -: 1453:
        -: 1454:static int
       24: 1455:test_cmdline_callback_(int id, const char* arg)
        -: 1456:{
       24: 1457:    switch(id) {
    #####: 1458:        case 's':
    #####: 1459:            test_skip_mode_ = 1;
    #####: 1460:            break;
        -: 1461:
    #####: 1462:        case 'e':
    #####: 1463:            if(arg == NULL || strcmp(arg, "always") == 0) {
    #####: 1464:                test_no_exec_ = 0;
    #####: 1465:            } else if(strcmp(arg, "never") == 0) {
    #####: 1466:                test_no_exec_ = 1;
    #####: 1467:            } else if(strcmp(arg, "auto") == 0) {
        -: 1468:                /*noop*/
        -: 1469:            } else {
    #####: 1470:                fprintf(stderr, "%s: Unrecognized argument '%s' for option --exec.\n", test_argv0_, arg);
    #####: 1471:                fprintf(stderr, "Try '%s --help' for more information.\n", test_argv0_);
    #####: 1472:                test_exit_(2);
        -: 1473:            }
    #####: 1474:            break;
        -: 1475:
        4: 1476:        case 'E':
        4: 1477:            test_no_exec_ = 1;
        4: 1478:            break;
        -: 1479:
    #####: 1480:        case 't':
        -: 1481:#if defined ACUTEST_WIN_  ||  defined ACUTEST_HAS_POSIX_TIMER_
    #####: 1482:            if(arg == NULL || strcmp(arg, "real") == 0) {
    #####: 1483:                test_timer_ = 1;
        -: 1484:    #ifndef ACUTEST_WIN_
        -: 1485:            } else if(strcmp(arg, "cpu") == 0) {
        -: 1486:                test_timer_ = 2;
        -: 1487:    #endif
        -: 1488:            } else {
    #####: 1489:                fprintf(stderr, "%s: Unrecognized argument '%s' for option --time.\n", test_argv0_, arg);
    #####: 1490:                fprintf(stderr, "Try '%s --help' for more information.\n", test_argv0_);
    #####: 1491:                test_exit_(2);
        -: 1492:            }
        -: 1493:#endif
    #####: 1494:            break;
        -: 1495:
        4: 1496:        case 'S':
        4: 1497:            test_no_summary_ = 1;
        4: 1498:            break;
        -: 1499:
    #####: 1500:        case 'T':
    #####: 1501:            test_tap_ = 1;
    #####: 1502:            break;
        -: 1503:
    #####: 1504:        case 'l':
    #####: 1505:            test_list_names_();
    #####: 1506:            test_exit_(0);
    #####: 1507:            break;
        -: 1508:
        4: 1509:        case 'v':
       4*: 1510:            test_verbose_level_ = (arg != NULL ? atoi(arg) : test_verbose_level_+1);
        4: 1511:            break;
        -: 1512:
    #####: 1513:        case 'q':
    #####: 1514:            test_verbose_level_ = 0;
    #####: 1515:            break;
        -: 1516:
        4: 1517:        case 'c':
        4: 1518:            if(arg == NULL || strcmp(arg, "always") == 0) {
        4: 1519:                test_colorize_ = 1;
    #####: 1520:            } else if(strcmp(arg, "never") == 0) {
    #####: 1521:                test_colorize_ = 0;
    #####: 1522:            } else if(strcmp(arg, "auto") == 0) {
        -: 1523:                /*noop*/
        -: 1524:            } else {
    #####: 1525:                fprintf(stderr, "%s: Unrecognized argument '%s' for option --color.\n", test_argv0_, arg);
    #####: 1526:                fprintf(stderr, "Try '%s --help' for more information.\n", test_argv0_);
    #####: 1527:                test_exit_(2);
        -: 1528:            }
        4: 1529:            break;
        -: 1530:
    #####: 1531:        case 'C':
    #####: 1532:            test_colorize_ = 0;
    #####: 1533:            break;
        -: 1534:
    #####: 1535:        case 'h':
    #####: 1536:            test_help_();
    #####: 1537:            test_exit_(0);
    #####: 1538:            break;
        -: 1539:
        4: 1540:        case 'w':
        4: 1541:            test_worker_ = 1;
        4: 1542:            test_worker_index_ = atoi(arg);
        4: 1543:            break;
    #####: 1544:        case 'x':
    #####: 1545:            test_xml_output_ = fopen(arg, "w");
    #####: 1546:            if (!test_xml_output_) {
    #####: 1547:                fprintf(stderr, "Unable to open '%s': %s\n", arg, strerror(errno));
    #####: 1548:                test_exit_(2);
        -: 1549:            }
    #####: 1550:            break;
        -: 1551:
        4: 1552:        case 0:
        4: 1553:            if(test_lookup_(arg) == 0) {
    #####: 1554:                fprintf(stderr, "%s: Unrecognized unit test '%s'\n", test_argv0_, arg);
    #####: 1555:                fprintf(stderr, "Try '%s --list' for list of unit tests.\n", test_argv0_);
    #####: 1556:                test_exit_(2);
        -: 1557:            }
        4: 1558:            break;
        -: 1559:
    #####: 1560:        case TEST_CMDLINE_OPTID_UNKNOWN_:
    #####: 1561:            fprintf(stderr, "Unrecognized command line option '%s'.\n", arg);
    #####: 1562:            fprintf(stderr, "Try '%s --help' for more information.\n", test_argv0_);
    #####: 1563:            test_exit_(2);
    #####: 1564:            break;
        -: 1565:
    #####: 1566:        case TEST_CMDLINE_OPTID_MISSINGARG_:
    #####: 1567:            fprintf(stderr, "The command line option '%s' requires an argument.\n", arg);
    #####: 1568:            fprintf(stderr, "Try '%s --help' for more information.\n", test_argv0_);
    #####: 1569:            test_exit_(2);
    #####: 1570:            break;
        -: 1571:
    #####: 1572:        case TEST_CMDLINE_OPTID_BOGUSARG_:
    #####: 1573:            fprintf(stderr, "The command line option '%s' does not expect an argument.\n", arg);
    #####: 1574:            fprintf(stderr, "Try '%s --help' for more information.\n", test_argv0_);
    #####: 1575:            test_exit_(2);
    #####: 1576:            break;
        -: 1577:    }
        -: 1578:
       24: 1579:    return 0;
        -: 1580:}
        -: 1581:
        -: 1582:
        -: 1583:#ifdef ACUTEST_LINUX_
        -: 1584:static int
        -: 1585:test_is_tracer_present_(void)
        -: 1586:{
        -: 1587:    /* Must be large enough so the line 'TracerPid: ${PID}' can fit in. */
        -: 1588:    static const int OVERLAP = 32;
        -: 1589:
        -: 1590:    char buf[256+OVERLAP+1];
        -: 1591:    int tracer_present = 0;
        -: 1592:    int fd;
        -: 1593:    size_t n_read = 0;
        -: 1594:
        -: 1595:    fd = open("/proc/self/status", O_RDONLY);
        -: 1596:    if(fd == -1)
        -: 1597:        return 0;
        -: 1598:
        -: 1599:    while(1) {
        -: 1600:        static const char pattern[] = "TracerPid:";
        -: 1601:        const char* field;
        -: 1602:
        -: 1603:        while(n_read < sizeof(buf) - 1) {
        -: 1604:            ssize_t n;
        -: 1605:
        -: 1606:            n = read(fd, buf + n_read, sizeof(buf) - 1 - n_read);
        -: 1607:            if(n <= 0)
        -: 1608:                break;
        -: 1609:            n_read += n;
        -: 1610:        }
        -: 1611:        buf[n_read] = '\0';
        -: 1612:
        -: 1613:        field = strstr(buf, pattern);
        -: 1614:        if(field != NULL  &&  field < buf + sizeof(buf) - OVERLAP) {
        -: 1615:            pid_t tracer_pid = (pid_t) atoi(field + sizeof(pattern) - 1);
        -: 1616:            tracer_present = (tracer_pid != 0);
        -: 1617:            break;
        -: 1618:        }
        -: 1619:
        -: 1620:        if(n_read == sizeof(buf)-1) {
        -: 1621:            memmove(buf, buf + sizeof(buf)-1 - OVERLAP, OVERLAP);
        -: 1622:            n_read = OVERLAP;
        -: 1623:        } else {
        -: 1624:            break;
        -: 1625:        }
        -: 1626:    }
        -: 1627:
        -: 1628:    close(fd);
        -: 1629:    return tracer_present;
        -: 1630:}
        -: 1631:#endif
        -: 1632:
        -: 1633:int
        5: 1634:main(int argc, char** argv)
        -: 1635:{
        -: 1636:    int i;
        5: 1637:    test_argv0_ = argv[0];
        -: 1638:
        -: 1639:#if defined ACUTEST_UNIX_
        -: 1640:    test_colorize_ = isatty(STDOUT_FILENO);
        -: 1641:#elif defined ACUTEST_WIN_
        -: 1642: #if defined _BORLANDC_
        -: 1643:    test_colorize_ = isatty(_fileno(stdout));
        -: 1644: #else
        5: 1645:    test_colorize_ = _isatty(_fileno(stdout));
        -: 1646: #endif
        -: 1647:#else
        -: 1648:    test_colorize_ = 0;
        -: 1649:#endif
        -: 1650:
        -: 1651:    /* Count all test units */
        5: 1652:    test_list_size_ = 0;
       25: 1653:    for(i = 0; test_list_[i].func != NULL; i++)
       20: 1654:        test_list_size_++;
        -: 1655:
        5: 1656:    test_details_ = (struct test_detail_*)calloc(test_list_size_, sizeof(struct test_detail_));
        5: 1657:    if(test_details_ == NULL) {
    #####: 1658:        fprintf(stderr, "Out of memory.\n");
    #####: 1659:        test_exit_(2);
        -: 1660:    }
        -: 1661:
        -: 1662:    /* Parse options */
        5: 1663:    test_cmdline_read_(test_cmdline_options_, argc, argv, test_cmdline_callback_);
        -: 1664:
        -: 1665:    /* Initialize the proper timer. */
        5: 1666:    test_timer_init_();
        -: 1667:
        -: 1668:#if defined(ACUTEST_WIN_)
        5: 1669:    SetUnhandledExceptionFilter(test_seh_exception_filter_);
        -: 1670:#ifdef _MSC_VER
        -: 1671:    _set_abort_behavior(0, _WRITE_ABORT_MSG);
        -: 1672:#endif
        -: 1673:#endif
        -: 1674:
        -: 1675:    /* By default, we want to run all tests. */
        5: 1676:    if(test_count_ == 0) {
        5: 1677:        for(i = 0; test_list_[i].func != NULL; i++)
        4: 1678:            test_remember_(i);
        -: 1679:    }
        -: 1680:
        -: 1681:    /* Guess whether we want to run unit tests as child processes. */
        5: 1682:    if(test_no_exec_ < 0) {
        1: 1683:        test_no_exec_ = 0;
        -: 1684:
        1: 1685:        if(test_count_ <= 1) {
    #####: 1686:            test_no_exec_ = 1;
        -: 1687:        } else {
        -: 1688:#ifdef ACUTEST_WIN_
        1: 1689:            if(IsDebuggerPresent())
    #####: 1690:                test_no_exec_ = 1;
        -: 1691:#endif
        -: 1692:#ifdef ACUTEST_LINUX_
        -: 1693:            if(test_is_tracer_present_())
        -: 1694:                test_no_exec_ = 1;
        -: 1695:#endif
        -: 1696:#ifdef RUNNING_ON_VALGRIND
        -: 1697:            /* RUNNING_ON_VALGRIND is provided by valgrind.h */
        -: 1698:            if(RUNNING_ON_VALGRIND)
        -: 1699:                test_no_exec_ = 1;
        -: 1700:#endif
        -: 1701:        }
        -: 1702:    }
        -: 1703:
        5: 1704:    if(test_tap_) {
        -: 1705:        /* TAP requires we know test result ("ok", "not ok") before we output
        -: 1706:         * anything about the test, and this gets problematic for larger verbose
        -: 1707:         * levels. */
    #####: 1708:        if(test_verbose_level_ > 2)
    #####: 1709:            test_verbose_level_ = 2;
        -: 1710:
        -: 1711:        /* TAP harness should provide some summary. */
    #####: 1712:        test_no_summary_ = 1;
        -: 1713:
    #####: 1714:        if(!test_worker_)
    #####: 1715:            printf("1..%d\n", (int) test_count_);
        -: 1716:    }
        -: 1717:
        5: 1718:    int index = test_worker_index_;
       25: 1719:    for(i = 0; test_list_[i].func != NULL; i++) {
       20: 1720:        int run = (test_details_[i].flags & TEST_FLAG_RUN_);
       20: 1721:        if (test_skip_mode_) /* Run all tests except those listed. */
    #####: 1722:            run = !run;
       20: 1723:        if(run)
        8: 1724:            test_run_(&test_list_[i], index++, i);
        -: 1725:    }
        -: 1726:
        -: 1727:    /* Write a summary */
        5: 1728:    if(!test_no_summary_ && test_verbose_level_ >= 1) {
        1: 1729:        if(test_verbose_level_ >= 3) {
    #####: 1730:            test_print_in_color_(TEST_COLOR_DEFAULT_INTENSIVE_, "Summary:\n");
        -: 1731:
    #####: 1732:            printf("  Count of all unit tests:     %4d\n", (int) test_list_size_);
    #####: 1733:            printf("  Count of run unit tests:     %4d\n", test_stat_run_units_);
    #####: 1734:            printf("  Count of failed unit tests:  %4d\n", test_stat_failed_units_);
    #####: 1735:            printf("  Count of skipped unit tests: %4d\n", (int) test_list_size_ - test_stat_run_units_);
        -: 1736:        }
        -: 1737:
        1: 1738:        if(test_stat_failed_units_ == 0) {
        1: 1739:            test_print_in_color_(TEST_COLOR_GREEN_INTENSIVE_, "SUCCESS:");
        1: 1740:            printf(" All unit tests have passed.\n");
        -: 1741:        } else {
    #####: 1742:            test_print_in_color_(TEST_COLOR_RED_INTENSIVE_, "FAILED:");
    #####: 1743:            printf(" %d of %d unit tests %s failed.\n",
        -: 1744:                    test_stat_failed_units_, test_stat_run_units_,
    #####: 1745:                    (test_stat_failed_units_ == 1) ? "has" : "have");
        -: 1746:        }
        -: 1747:
        1: 1748:        if(test_verbose_level_ >= 3)
    #####: 1749:            printf("\n");
        -: 1750:    }
        -: 1751:
        5: 1752:    if (test_xml_output_) {
        -: 1753:#if defined ACUTEST_UNIX_
        -: 1754:        char *suite_name = basename(argv[0]);
        -: 1755:#elif defined ACUTEST_WIN_
        -: 1756:        char suite_name[_MAX_FNAME];
    #####: 1757:        _splitpath(argv[0], NULL, NULL, suite_name, NULL);
        -: 1758:#else
        -: 1759:        const char *suite_name = argv[0];
        -: 1760:#endif
    #####: 1761:        fprintf(test_xml_output_, "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n");
    #####: 1762:        fprintf(test_xml_output_, "<testsuite name=\"%s\" tests=\"%d\" errors=\"%d\" failures=\"%d\" skip=\"%d\">\n",
        -: 1763:            suite_name, (int)test_list_size_, test_stat_failed_units_, test_stat_failed_units_,
    #####: 1764:            (int)test_list_size_ - test_stat_run_units_);
    #####: 1765:        for(i = 0; test_list_[i].func != NULL; i++) {
    #####: 1766:            struct test_detail_ *details = &test_details_[i];
    #####: 1767:            fprintf(test_xml_output_, "  <testcase name=\"%s\" time=\"%.2f\">\n", test_list_[i].name, details->duration);
    #####: 1768:            if (details->flags & TEST_FLAG_FAILURE_)
    #####: 1769:                fprintf(test_xml_output_, "    <failure />\n");
    #####: 1770:            if (!(details->flags & TEST_FLAG_FAILURE_) && !(details->flags & TEST_FLAG_SUCCESS_))
    #####: 1771:                fprintf(test_xml_output_, "    <skipped />\n");
    #####: 1772:            fprintf(test_xml_output_, "  </testcase>\n");
        -: 1773:        }
    #####: 1774:        fprintf(test_xml_output_, "</testsuite>\n");
    #####: 1775:        fclose(test_xml_output_);
        -: 1776:    }
        -: 1777:
        5: 1778:    test_cleanup_();
        -: 1779:
        5: 1780:    return (test_stat_failed_units_ == 0) ? 0 : 1;
        -: 1781:}
        -: 1782:
        -: 1783:
        -: 1784:#endif  /* #ifndef TEST_NO_MAIN */
        -: 1785:
        -: 1786:#ifdef _MSC_VER
        -: 1787:    #pragma warning(pop)
        -: 1788:#endif
        -: 1789:
        -: 1790:#ifdef __cplusplus
        -: 1791:    }  /* extern "C" */
        -: 1792:#endif
        -: 1793:
        -: 1794:#endif  /* #ifndef ACUTEST_H */
